import { BaseVisitor } from './base-visitor';
import { OperationVariablesToObject } from './variables-to-object';
import { DeclarationBlock, indent, wrapWithSingleQuotes, buildScalars } from './utils';
import { DEFAULT_SCALARS } from './scalars';
export class BaseTypesVisitor extends BaseVisitor {
    constructor(_schema, rawConfig, additionalConfig, defaultScalars = DEFAULT_SCALARS) {
        super(rawConfig, Object.assign({ enumValues: rawConfig.enumValues || {} }, additionalConfig), buildScalars(_schema, defaultScalars));
        this._schema = _schema;
        this._argumentsTransformer = new OperationVariablesToObject(this.scalars, this.convertName);
    }
    get scalarsDefinition() {
        const allScalars = Object.keys(this.config.scalars).map(scalarName => {
            const scalarValue = this.config.scalars[scalarName];
            return indent(`${scalarName}: ${scalarValue},`);
        });
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName('Scalars')
            .withBlock(allScalars.join('\n')).string;
    }
    setDeclarationBlockConfig(config) {
        this._declarationBlockConfig = config;
    }
    setArgumentsTransformer(argumentsTransfomer) {
        this._argumentsTransformer = argumentsTransfomer;
    }
    NonNullType(node) {
        const asString = node.type;
        return asString;
    }
    InputObjectTypeDefinition(node) {
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName(node))
            .withBlock(node.fields.join('\n')).string;
    }
    InputValueDefinition(node) {
        return indent(`${node.name}: ${node.type},`);
    }
    Name(node) {
        return node.value;
    }
    FieldDefinition(node) {
        const typeString = node.type;
        return indent(`${node.name}: ${typeString},`);
    }
    UnionTypeDefinition(node, key, parent) {
        const originalNode = parent[key];
        const possibleTypes = originalNode.types.map(t => (this.scalars[t.name.value] ? this._getScalar(t.name.value) : this.convertName(t))).join(' | ');
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName(node))
            .withContent(possibleTypes).string;
    }
    ObjectTypeDefinition(node, key, parent) {
        const originalNode = parent[key];
        const interfaces = originalNode.interfaces && node.interfaces.length > 0 ? originalNode.interfaces.map(i => this.convertName(i)).join(' & ') + ' & ' : '';
        const typeDefinition = new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName(node))
            .withContent(interfaces)
            .withBlock(node.fields.join('\n')).string;
        const original = parent[key];
        const fieldsWithArguments = original.fields.filter(field => field.arguments && field.arguments.length > 0);
        const fieldsArguments = fieldsWithArguments.map(field => {
            const name = original.name.value +
                this.convertName(field, {
                    useTypesPrefix: false,
                }) +
                'Args';
            return new DeclarationBlock(this._declarationBlockConfig)
                .export()
                .asKind('type')
                .withName(this.convertName(name))
                .withBlock(this._argumentsTransformer.transform(field.arguments)).string;
        });
        return [typeDefinition, ...fieldsArguments].filter(f => f).join('\n\n');
    }
    InterfaceTypeDefinition(node) {
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName(node))
            .withBlock(node.fields.join('\n')).string;
    }
    ScalarTypeDefinition(node) {
        // We empty this because we handle scalars in a different way, see constructor.
        return '';
    }
    EnumTypeDefinition(node) {
        return new DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('enum')
            .withName(this.convertName(node))
            .withBlock(this.buildEnumValuesBlock(node.values)).string;
    }
    buildEnumValuesBlock(values) {
        return values.map(enumOption => indent(`${this.convertName(enumOption)}${this._declarationBlockConfig.enumNameValueSeparator} ${wrapWithSingleQuotes(this.config.enumValues[enumOption.name] || enumOption.name)}`)).join(',\n');
    }
    DirectiveDefinition(node) {
        return '';
    }
    _getScalar(name) {
        return `Scalars['${name}']`;
    }
    _getTypeForNode(node) {
        const typeAsString = node.name;
        if (this.scalars[typeAsString]) {
            return this._getScalar(typeAsString);
        }
        return this.convertName(node);
    }
    NamedType(node) {
        return this._getTypeForNode(node);
    }
    ListType(node) {
        const asString = node.type;
        return this.wrapWithListType(asString);
    }
    SchemaDefinition() {
        return null;
    }
    wrapWithListType(str) {
        return `Array<${str}>`;
    }
}
//# sourceMappingURL=base-types-visitor.js.map