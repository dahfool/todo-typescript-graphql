import { pascalCase } from 'change-case';
import { Kind, isNonNullType, isListType, isScalarType } from 'graphql';
function isWrapperType(t) {
    return isListType(t) || isNonNullType(t);
}
export const getConfigValue = (value, defaultValue) => {
    if (value === null || value === undefined) {
        return defaultValue;
    }
    return value;
};
export function getBaseType(type) {
    if (isWrapperType(type)) {
        return getBaseType(type.ofType);
    }
    else {
        return type;
    }
}
export function quoteIfNeeded(array, joinWith = ' & ') {
    if (array.length === 0) {
        return '';
    }
    else if (array.length === 1) {
        return array[0];
    }
    else {
        return `(${array.join(joinWith)})`;
    }
}
export function block(array) {
    return array && array.length !== 0 ? '{\n' + array.join('\n') + '\n}' : '';
}
export function wrapWithSingleQuotes(str) {
    return `'${str}'`;
}
export function breakLine(str) {
    return str + '\n';
}
export function indent(str, count = 1) {
    return new Array(count).fill('  ').join('') + str;
}
export class DeclarationBlock {
    constructor(_config) {
        this._config = _config;
        this._export = false;
        this._name = null;
        this._kind = null;
        this._methodName = null;
        this._content = null;
        this._block = null;
        this._nameGenerics = null;
        this._config = Object.assign({ blockWrapper: '', blockTransformer: block => block, enumNameValueSeparator: ':' }, this._config);
    }
    export(exp = true) {
        this._export = exp;
        return this;
    }
    asKind(kind) {
        this._kind = kind;
        return this;
    }
    withMethodCall(methodName) {
        this._methodName = methodName;
        return this;
    }
    withBlock(block) {
        this._block = block;
        return this;
    }
    withContent(content) {
        this._content = content;
        return this;
    }
    withName(name, generics = null) {
        this._name = name;
        this._nameGenerics = generics;
        return this;
    }
    get string() {
        let result = '';
        if (this._export) {
            result += 'export ';
        }
        if (this._kind) {
            let extra = '';
            let name = '';
            if (['type', 'const', 'var', 'let'].includes(this._kind)) {
                extra = '= ';
            }
            if (this._name) {
                name = this._name + (this._nameGenerics || '') + ' ';
            }
            result += this._kind + ' ' + name + extra;
        }
        if (this._block) {
            if (this._content) {
                result += this._content;
            }
            const before = '{' + this._config.blockWrapper;
            const after = this._config.blockWrapper + '}';
            const block = [before, this._block, after].join('\n');
            if (this._methodName) {
                result += `${this._methodName}(${this._config.blockTransformer(block)})`;
            }
            else {
                result += this._config.blockTransformer(block);
            }
        }
        else if (this._content) {
            result += this._content;
        }
        else if (this._kind) {
            result += '{}';
        }
        return result + (this._kind === 'interface' || this._kind === 'enum' ? '' : ';') + '\n';
    }
}
export function getBaseTypeNode(typeNode) {
    if (typeNode.kind === Kind.LIST_TYPE || typeNode.kind === Kind.NON_NULL_TYPE) {
        return getBaseTypeNode(typeNode.type);
    }
    return typeNode;
}
export function toPascalCase(str) {
    return str
        .split('_')
        .map(s => pascalCase(s))
        .join('_');
}
export const wrapTypeWithModifiers = (prefix = '') => (baseType, type) => {
    if (isNonNullType(type)) {
        return wrapTypeWithModifiers(prefix)(baseType, type.ofType).substr(1);
    }
    else if (isListType(type)) {
        const innerType = wrapTypeWithModifiers(prefix)(baseType, type.ofType);
        return `${prefix}Array<${innerType}>`;
    }
    else {
        return `${prefix}${baseType}`;
    }
};
export function buildScalars(schema, scalarsMapping) {
    const typeMap = schema.getTypeMap();
    let result = Object.assign({}, scalarsMapping);
    Object.keys(typeMap)
        .map(typeName => typeMap[typeName])
        .filter(type => isScalarType(type))
        .map((scalarType) => {
        const name = scalarType.name;
        const value = scalarsMapping[name] || 'any';
        result[name] = value;
    });
    return result;
}
//# sourceMappingURL=utils.js.map