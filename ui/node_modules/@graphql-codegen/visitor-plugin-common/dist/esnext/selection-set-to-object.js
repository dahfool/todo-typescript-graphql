import { Kind, isObjectType, isUnionType, isInterfaceType, isEnumType, isEqualType, SchemaMetaFieldDef, TypeMetaFieldDef, isScalarType } from 'graphql';
import { getBaseType, quoteIfNeeded } from './utils';
function isMetadataFieldName(name) {
    return ['__schema', '__type'].includes(name);
}
function isRootType(type, schema) {
    return (isEqualType(type, schema.getQueryType()) ||
        isEqualType(type, schema.getMutationType()) ||
        isEqualType(type, schema.getSubscriptionType()));
}
const metadataFieldMap = {
    __schema: SchemaMetaFieldDef,
    __type: TypeMetaFieldDef
};
export class SelectionSetToObject {
    constructor(_scalars, _schema, _convertName, _addTypename, _parentSchemaType, _selectionSet) {
        this._scalars = _scalars;
        this._schema = _schema;
        this._convertName = _convertName;
        this._addTypename = _addTypename;
        this._parentSchemaType = _parentSchemaType;
        this._selectionSet = _selectionSet;
        this._primitiveFields = [];
        this._primitiveAliasedFields = [];
        this._linksFields = [];
        this._fragmentSpreads = [];
        this._inlineFragments = {};
        this._queriedForTypename = false;
    }
    createNext(parentSchemaType, selectionSet) {
        throw new Error(`You must override createNext in your SelectionSetToObject implementation!`);
    }
    wrapTypeWithModifiers(baseType, type) {
        throw new Error(`You must override wrapTypeWithModifiers in your SelectionSetToObject implementation!`);
    }
    _collectField(field) {
        if (field.name.value === '__typename') {
            this._queriedForTypename = true;
            return;
        }
        if (isObjectType(this._parentSchemaType) || isInterfaceType(this._parentSchemaType)) {
            let schemaField;
            if (isRootType(this._parentSchemaType, this._schema) && isMetadataFieldName(field.name.value)) {
                schemaField = metadataFieldMap[field.name.value];
            }
            else {
                schemaField = this._parentSchemaType.getFields()[field.name.value];
            }
            const rawType = schemaField.type;
            const baseType = getBaseType(rawType);
            const typeName = baseType.name;
            if (this._scalars[typeName] || isEnumType(baseType) || isScalarType(baseType)) {
                if (field.alias && field.alias.value) {
                    this._primitiveAliasedFields.push({
                        fieldName: field.name.value,
                        alias: field.alias.value
                    });
                }
                else {
                    this._primitiveFields.push(field.name.value);
                }
            }
            else {
                const selectionSetToObject = this.createNext(baseType, field.selectionSet);
                this._linksFields.push({
                    alias: field.alias ? field.alias.value : null,
                    name: field.name.value,
                    type: typeName,
                    selectionSet: this.wrapTypeWithModifiers(selectionSetToObject.string, rawType)
                });
            }
        }
    }
    _collectFragmentSpread(node) {
        this._fragmentSpreads.push(node.name.value);
    }
    _collectInlineFragment(node) {
        const onType = node.typeCondition.name.value;
        const schemaType = this._schema.getType(onType);
        const selectionSet = this.createNext(schemaType, node.selectionSet);
        if (!this._inlineFragments[onType]) {
            this._inlineFragments[onType] = [];
        }
        this._inlineFragments[onType].push(selectionSet.string);
    }
    get string() {
        if (!this._selectionSet || !this._selectionSet.selections || this._selectionSet.selections.length === 0) {
            return '';
        }
        const { selections } = this._selectionSet;
        for (const selection of selections) {
            switch (selection.kind) {
                case Kind.FIELD:
                    this._collectField(selection);
                    break;
                case Kind.FRAGMENT_SPREAD:
                    this._collectFragmentSpread(selection);
                    break;
                case Kind.INLINE_FRAGMENT:
                    this._collectInlineFragment(selection);
                    break;
            }
        }
        const parentName = this._convertName(this._parentSchemaType.name, {
            useTypesPrefix: true
        });
        const typeName = this._addTypename || this._queriedForTypename ? this.buildTypeNameField() : null;
        const baseFields = this.buildPrimitiveFields(parentName, this._primitiveFields);
        const aliasBaseFields = this.buildAliasedPrimitiveFields(parentName, this._primitiveAliasedFields);
        const linksFields = this.buildLinkFields(this._linksFields);
        const inlineFragments = this.buildInlineFragments(this._inlineFragments);
        const fragmentSpreads = this.buildFragmentSpread(this._fragmentSpreads);
        const fieldsSet = [typeName, baseFields, aliasBaseFields, linksFields, fragmentSpreads, inlineFragments].filter(f => f && f !== '');
        return this.mergeAllFields(fieldsSet);
    }
    mergeAllFields(fieldsSet) {
        return quoteIfNeeded(fieldsSet, ' & ');
    }
    buildTypeNameField() {
        const possibleTypes = [];
        if (!isUnionType(this._parentSchemaType) && !isInterfaceType(this._parentSchemaType)) {
            possibleTypes.push(this._parentSchemaType.name);
        }
        if (possibleTypes.length === 0) {
            return null;
        }
        return `{ ${this.formatNamedField('__typename')}${this._queriedForTypename ? '' : '?'}: ${possibleTypes
            .map(t => `'${t}'`)
            .join(' | ')} }`;
    }
    buildPrimitiveFields(parentName, fields) {
        if (fields.length === 0) {
            return null;
        }
        return `Pick<${parentName}, ${fields.map(field => `'${field}'`).join(' | ')}>`;
    }
    buildAliasedPrimitiveFields(parentName, fields) {
        if (fields.length === 0) {
            return null;
        }
        return `{ ${fields
            .map(aliasedField => `${this.formatNamedField(aliasedField.alias)}: ${parentName}['${aliasedField.fieldName}']`)
            .join(', ')} }`;
    }
    formatNamedField(name) {
        return name;
    }
    buildLinkFields(fields) {
        if (fields.length === 0) {
            return null;
        }
        return `{ ${fields
            .map(field => `${this.formatNamedField(field.alias || field.name)}: ${field.selectionSet}`)
            .join(', ')} }`;
    }
    buildInlineFragments(inlineFragments) {
        const allPossibleTypes = Object.keys(inlineFragments).map(typeName => inlineFragments[typeName].join(' & '));
        return allPossibleTypes.length === 0 ? null : `(${allPossibleTypes.join(' | ')})`;
    }
    buildFragmentSpread(fragmentsSpread) {
        if (fragmentsSpread.length === 0) {
            return null;
        }
        return quoteIfNeeded(fragmentsSpread.map(fragmentName => this._convertName(fragmentName, {
            suffix: 'Fragment',
            useTypesPrefix: true
        })), ' & ');
    }
}
//# sourceMappingURL=selection-set-to-object.js.map