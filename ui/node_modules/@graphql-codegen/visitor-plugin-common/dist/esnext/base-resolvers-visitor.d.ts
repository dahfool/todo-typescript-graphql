import { ParsedConfig, RawConfig, BaseVisitor } from './base-visitor';
import { ScalarsMap } from './types';
import { DeclarationBlockConfig } from './utils';
import { NameNode, ListTypeNode, NamedTypeNode, FieldDefinitionNode, ObjectTypeDefinitionNode, GraphQLSchema, NonNullTypeNode, UnionTypeDefinitionNode, ScalarTypeDefinitionNode, InterfaceTypeDefinitionNode } from 'graphql';
import { DirectiveDefinitionNode } from 'graphql';
import { OperationVariablesToObject } from './variables-to-object';
import { ParsedMapper } from './mappers';
export interface ParsedResolversConfig extends ParsedConfig {
    contextType: ParsedMapper;
    mappers: {
        [typeName: string]: ParsedMapper;
    };
}
export interface RawResolversConfig extends RawConfig {
    /**
     * @name contextType
     * @type string
     * @description Use this configuration to set a custom type for your `context`, and it will
     * effect all the resolvers, without the need to override it using generics each time.
     * If you wish to use an external type and import it from another file, you can use `add` plugin
     * and add the required `import` statement, or you can use a `module#type` syntax.
     *
     * @example Custom Context Type
     * ```yml
     * plugins
     *   config:
     *     contextType: MyContext
     * ```
     * @example Custom Context Type
     * ```yml
     * plugins
     *   config:
     *     contextType: ./my-types#MyContext
     * ```
     */
    contextType?: string;
    /**
     * @name mappers
     * @type Object
     * @description Replaces a GraphQL type usage with a custom type, allowing you to return custom object from
     * your resolvers.
     * You can use a `module#type` syntax.
     *
     * @example Custom Context Type
     * ```yml
     * plugins
     *   config:
     *     mappers:
     *       User: ./my-models#UserDbObject
     * ```
     */
    mappers?: {
        [typeName: string]: string;
    };
}
export declare class BaseResolversVisitor<TRawConfig extends RawResolversConfig = RawResolversConfig, TPluginConfig extends ParsedResolversConfig = ParsedResolversConfig> extends BaseVisitor<TRawConfig, TPluginConfig> {
    private _schema;
    protected _parsedConfig: TPluginConfig;
    protected _declarationBlockConfig: DeclarationBlockConfig;
    protected _collectedResolvers: {
        [key: string]: string;
    };
    protected _collectedDirectiveResolvers: {
        [key: string]: string;
    };
    protected _variablesTransfomer: OperationVariablesToObject;
    constructor(rawConfig: TRawConfig, additionalConfig: TPluginConfig, _schema: GraphQLSchema, defaultScalars?: ScalarsMap);
    readonly schema: GraphQLSchema;
    readonly mappersImports: string[];
    protected buildMapperImport(source: string, types: string[]): string;
    setDeclarationBlockConfig(config: DeclarationBlockConfig): void;
    setVariablesTransformer(variablesTransfomer: OperationVariablesToObject): void;
    getRootResolver(): string;
    protected formatRootResolver(schemaTypeName: string, resolverType: string): string;
    getAllDirectiveResolvers(): string;
    Name(node: NameNode): string;
    ListType(node: ListTypeNode): string;
    protected _getScalar(name: string): string;
    NamedType(node: NamedTypeNode): string;
    NonNullType(node: NonNullTypeNode): string;
    FieldDefinition(node: FieldDefinitionNode, key: string | number, parent: any): (parentName: string) => string;
    ObjectTypeDefinition(node: ObjectTypeDefinitionNode): string;
    UnionTypeDefinition(node: UnionTypeDefinitionNode, key: string | number, parent: any): string;
    ScalarTypeDefinition(node: ScalarTypeDefinitionNode): string;
    DirectiveDefinition(node: DirectiveDefinitionNode): string;
    InterfaceTypeDefinition(node: InterfaceTypeDefinitionNode): string;
    SchemaDefinition(): any;
}
