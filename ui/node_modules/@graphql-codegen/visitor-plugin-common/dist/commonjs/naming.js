"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const plugin_helpers_1 = require("@graphql-codegen/plugin-helpers");
const utils_1 = require("./utils");
function getKind(node) {
    if (typeof node === 'string') {
        return 'typeNames';
    }
    if (['EnumValueDefinition', 'EnumValue'].includes(node.kind)) {
        return 'enumValues';
    }
    return 'typeNames';
}
function getName(node) {
    if (typeof node === 'string') {
        return node;
    }
    switch (node.kind) {
        case 'OperationDefinition':
        case 'Variable':
        case 'Argument':
        case 'FragmentSpread':
        case 'FragmentDefinition':
        case 'ObjectField':
        case 'Directive':
        case 'NamedType':
        case 'ScalarTypeDefinition':
        case 'ObjectTypeDefinition':
        case 'FieldDefinition':
        case 'InputValueDefinition':
        case 'InterfaceTypeDefinition':
        case 'UnionTypeDefinition':
        case 'EnumTypeDefinition':
        case 'EnumValueDefinition':
        case 'InputObjectTypeDefinition':
        case 'DirectiveDefinition': {
            return getName(node.name);
        }
        case 'Name': {
            return node.value;
        }
        case 'Field': {
            return getName(node.alias || node.name);
        }
        case 'VariableDefinition': {
            return getName(node.variable);
        }
    }
    return undefined;
}
function convertFactory(config) {
    function resolveConventionName(type) {
        if (!config.namingConvention) {
            return utils_1.toPascalCase;
        }
        if (typeof config.namingConvention === 'string') {
            return plugin_helpers_1.resolveExternalModuleAndFn(config.namingConvention);
        }
        if (config.namingConvention[type] === 'keep') {
            return str => str;
        }
        if (typeof config.namingConvention[type] === 'string') {
            return plugin_helpers_1.resolveExternalModuleAndFn(config.namingConvention[type]);
        }
        return config.namingConvention[type];
    }
    return (node, opts) => {
        const prefix = opts && opts.prefix;
        const suffix = opts && opts.suffix;
        const kind = getKind(node);
        const str = [prefix || '', getName(node), suffix || ''].join('');
        return resolveConventionName(kind)(str);
    };
}
exports.convertFactory = convertFactory;
//# sourceMappingURL=naming.js.map