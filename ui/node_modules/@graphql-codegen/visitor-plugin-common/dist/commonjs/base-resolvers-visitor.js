"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const base_visitor_1 = require("./base-visitor");
const autoBind = require("auto-bind");
const scalars_1 = require("./scalars");
const utils_1 = require("./utils");
const graphql_1 = require("graphql");
const variables_to_object_1 = require("./variables-to-object");
const mappers_1 = require("./mappers");
class BaseResolversVisitor extends base_visitor_1.BaseVisitor {
    constructor(rawConfig, additionalConfig, _schema, defaultScalars = scalars_1.DEFAULT_SCALARS) {
        super(rawConfig, Object.assign({ contextType: mappers_1.parseMapper(rawConfig.contextType || 'any'), mappers: mappers_1.transformMappers(rawConfig.mappers || {}) }, (additionalConfig || {})), utils_1.buildScalars(_schema, defaultScalars));
        this._schema = _schema;
        this._declarationBlockConfig = {};
        this._collectedResolvers = {};
        this._collectedDirectiveResolvers = {};
        autoBind(this);
        this._variablesTransfomer = new variables_to_object_1.OperationVariablesToObject(this.scalars, this.convertName);
    }
    get schema() {
        return this._schema;
    }
    get mappersImports() {
        const groupedMappers = {};
        Object.keys(this.config.mappers)
            .filter(gqlTypeName => this.config.mappers[gqlTypeName].isExternal)
            .forEach(gqlTypeName => {
            const mapper = this.config.mappers[gqlTypeName];
            if (!groupedMappers[mapper.source]) {
                groupedMappers[mapper.source] = [];
            }
            groupedMappers[mapper.source].push(mapper.type);
        });
        if (this.config.contextType.isExternal) {
            if (!groupedMappers[this.config.contextType.source]) {
                groupedMappers[this.config.contextType.source] = [];
            }
            groupedMappers[this.config.contextType.source].push(this.config.contextType.type);
        }
        return Object.keys(groupedMappers).map(source => this.buildMapperImport(source, groupedMappers[source]));
    }
    buildMapperImport(source, types) {
        return `import { ${types.join(', ')} } from '${source}';`;
    }
    setDeclarationBlockConfig(config) {
        this._declarationBlockConfig = config;
    }
    setVariablesTransformer(variablesTransfomer) {
        this._variablesTransfomer = variablesTransfomer;
    }
    getRootResolver() {
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName('IResolvers'), `<Context = ${this.config.contextType.type}>`)
            .withBlock(Object.keys(this._collectedResolvers)
            .map(schemaTypeName => {
            const resolverType = this._collectedResolvers[schemaTypeName];
            return utils_1.indent(this.formatRootResolver(schemaTypeName, resolverType));
        })
            .join('\n')).string;
    }
    formatRootResolver(schemaTypeName, resolverType) {
        return `${schemaTypeName}?: ${resolverType},`;
    }
    getAllDirectiveResolvers() {
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(this.convertName('IDirectiveResolvers'), `<Context = ${this.config.contextType.type}>`)
            .withBlock(Object.keys(this._collectedDirectiveResolvers)
            .map(schemaTypeName => {
            const resolverType = this._collectedDirectiveResolvers[schemaTypeName];
            return utils_1.indent(this.formatRootResolver(schemaTypeName, resolverType));
        })
            .join('\n')).string;
    }
    Name(node) {
        return node.value;
    }
    ListType(node) {
        const asString = node.type;
        return `ArrayOrIterable<${asString}>`;
    }
    _getScalar(name) {
        return `Scalars['${name}']`;
    }
    NamedType(node) {
        const nameStr = node.name;
        if (this.config.scalars[nameStr]) {
            return this._getScalar(nameStr);
        }
        return this.convertName(node);
    }
    NonNullType(node) {
        const asString = node.type;
        return asString;
    }
    FieldDefinition(node, key, parent) {
        const hasArguments = node.arguments && node.arguments.length > 0;
        return (parentName) => {
            const original = parent[key];
            const realType = utils_1.getBaseTypeNode(original.type).name.value;
            const mappedType = this.config.mappers[realType] ? this._variablesTransfomer.wrapAstTypeWithModifiers(this.config.mappers[realType].type, original.type) : node.type;
            const subscriptionType = this._schema.getSubscriptionType();
            const isSubscriptionType = subscriptionType && subscriptionType.name === parentName;
            return utils_1.indent(`${node.name}?: ${isSubscriptionType ? 'SubscriptionResolver' : 'Resolver'}<${mappedType}, ParentType, Context${hasArguments
                ? `, ${this.convertName(parentName, {
                    useTypesPrefix: true,
                }) +
                    this.convertName(node.name, {
                        useTypesPrefix: false,
                    }) +
                    'Args'}`
                : ''}>,`);
        };
    }
    ObjectTypeDefinition(node) {
        const name = this.convertName(node, {
            suffix: 'Resolvers',
        });
        let type = null;
        if (this.config.mappers[node.name]) {
            type = this.config.mappers[node.name].type;
        }
        else {
            type = this.config.scalars[node.name] || this.convertName(node);
        }
        const block = new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(name, `<Context = ${this.config.contextType.type}, ParentType = ${type}>`)
            .withBlock(node.fields.map((f) => f(node.name)).join('\n'));
        this._collectedResolvers[node.name] = name + '<Context>';
        return block.string;
    }
    UnionTypeDefinition(node, key, parent) {
        const name = this.convertName(node, {
            suffix: 'Resolvers',
        });
        const originalNode = parent[key];
        const possibleTypes = originalNode.types
            .map(node => this.convertName(node))
            .map(f => `'${f}'`)
            .join(' | ');
        this._collectedResolvers[node.name] = name;
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(name, `<Context = ${this.config.contextType.type}, ParentType = ${node.name}>`)
            .withBlock(utils_1.indent(`__resolveType: TypeResolveFn<${possibleTypes}>`)).string;
    }
    ScalarTypeDefinition(node) {
        const nameAsString = node.name;
        const baseName = this.scalars[nameAsString] ? this._getScalar(nameAsString) : this.convertName(node);
        this._collectedResolvers[node.name] = 'GraphQLScalarType';
        return new utils_1.DeclarationBlock(Object.assign({}, this._declarationBlockConfig, { blockTransformer(block) {
                return block;
            } }))
            .export()
            .asKind('interface')
            .withName(this.convertName(node, {
            suffix: 'ScalarConfig',
        }), ` extends GraphQLScalarTypeConfig<${baseName}, any>`)
            .withBlock(utils_1.indent(`name: '${node.name}'`)).string;
    }
    DirectiveDefinition(node) {
        const directiveName = this.convertName(node, {
            suffix: 'DirectiveResolver',
        });
        const hasArguments = node.arguments && node.arguments.length > 0;
        const directiveArgs = hasArguments ? this._variablesTransfomer.transform(node.arguments) : '';
        this._collectedDirectiveResolvers[node.name] = directiveName + '<any, any, Context>';
        return new utils_1.DeclarationBlock(Object.assign({}, this._declarationBlockConfig, { blockTransformer(block) {
                return block;
            } }))
            .export()
            .asKind('type')
            .withName(directiveName, `<Result, Parent, Context = ${this.config.contextType.type}, Args = { ${directiveArgs} }>`)
            .withContent(`DirectiveResolverFn<Result, Parent, Context, Args>`).string;
    }
    InterfaceTypeDefinition(node) {
        const name = this.convertName(node, {
            suffix: 'Resolvers',
        });
        const allTypesMap = this._schema.getTypeMap();
        const implementingTypes = [];
        this._collectedResolvers[node.name] = name;
        for (const graphqlType of Object.values(allTypesMap)) {
            if (graphqlType instanceof graphql_1.GraphQLObjectType) {
                const allInterfaces = graphqlType.getInterfaces();
                if (allInterfaces.find(int => int.name === node.name)) {
                    implementingTypes.push(graphqlType.name);
                }
            }
        }
        return new utils_1.DeclarationBlock(this._declarationBlockConfig)
            .export()
            .asKind('type')
            .withName(name, `<Context = ${this.config.contextType.type}, ParentType = ${node.name}>`)
            .withBlock([utils_1.indent(`__resolveType: TypeResolveFn<${implementingTypes.map(name => `'${name}'`).join(' | ')}>,`), ...(node.fields || []).map((f) => f(node.name))].join('\n')).string;
    }
    SchemaDefinition() {
        return null;
    }
}
exports.BaseResolversVisitor = BaseResolversVisitor;
//# sourceMappingURL=base-resolvers-visitor.js.map